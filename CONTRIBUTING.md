
# Nautilus Contribution Guidelines

We are happy to have contributors to our project. If you'd like to contribute
a feature, bug fix, or other component to Nautilus, we ask that you first read these
guidelines.

## Table of Contents
- [How Can I Contribute?](#how-can-i-contribute)
- [Development Model](#development-model)


## How Can I Contribute?

### Reporting Bugs
You can report bugs in the issue tracker for the
Github page. Make sure to label the issue appropriately, 
and provide a verbose description which outlines in detail
everything necessary for us (or others) to reproduce the
bug. This includes:

1. Your development environment (which version of `gcc`, what
host are you compiling on? 
2. How did you compile Nautilus? You can even attach your `.config` file
(generated by running `make menuconfig` so we can know which exact
configuration you're using.
3. Your runtime environment: if running with `qemu`, which flags
did you provide. If you're running on bare hardware, what are the
hardware specs? (i.e. CPU architecture, vendor, how much RAM, which
BIOS etc.)
4. What features did you add or what changes did you make? Is this
code you've added? Did you tweak the `Makefile`?
5. Is the bug deterministic? If not, under what conditions does it seem
most likely to arise?

### Creating an Issue
We've set up several labels to organize issues into logical groups. 
For example, if it is a bug that you're filing, label your issue
with the `bug` label. Use every appropriate label from the list. We've
created a few custom labels of interest:

* `bug`: Something is broken.
* `beginner`: This is an issue or feature that a newcomer would
likely be able to work on.
* `compilation`: This is an issue specific to compilation and
the build process.
* `documentation`: This is an issue that only relates to commenting
or documentation.
* `hardware only`: This issue only affects bare hardware, not virtual environments.
* `virtual only`: This issue only relates to virtual environments, e.g. QEMU or KVM.
* `hardware + virtual`: The issue is relevant to both physical and virtual hardware.
* `runtime`: The issue relates to a particular runtime system, not Nautilus itself.
* `enhancement`: Used for feature requests (wish list items).
* `question`: General questions and inquiries.


### Your First Code Contribution
Follow the process below, and submit a pull request.



## Development Model

### Getting Started
When developing with Nautilus, it's best to get a good dev environment
set up first, e.g. using a personal Linux box or VM with QEMU installed, or
a physical machine which you can control via serial port or BMC (e.g.
with [IPMI + PXE boot](http://cs.iit.edu/~khale/docs/notes/pxe-server.html) 
or with [PXE boot and a serial cable](http://cs.iit.edu/~khale/docs/notes/pxe.html)).

We've provided a default `Vagrantfile` to use with [Vagrant](https://www.vagrantup.com/) for
rapid development. See more in the [README](https://github.com/HExSA-Lab/nautilus/blob/master/README.md).

### Contributing Code
You'll first want to make sure you have a Github account. Then, head
over to the [Nautilus github page](https://github.com/HExSA-Lab/nautilus.git)
and use the **fork** feature. Now, on your dev machine, you can clone like so:

    git clone git@github.com:USERNAME/nautilus.git

### Keeping Your Fork Synchronized

Unless you're planning on submitting a quick fix, you'll want to make sure that
your fork is up to date with our `master` branch. You can do this with _upstream_
tracking:

    # Add upstream to the list of remotes
    git remote add upstream https://github.com/HExSA-Lab/nautilus.git

    # Verify that the new remote is added
    git remote -v

Now, whenever you want to make sure your fork is up to date with the latest
upstream changes, you'll first fetch all the upstream branches:

    # Fetch from upstream
    git fetch upstream

    # Look at all branches, including those from upstream
    git branch -va

Now, checkout your _own_ master branch and merge it with the upstream's
master branch:

    git checkout master
    git merge upstream/master

If there are no unique commits on your _local_ master branch, Git will just
do a fast-forward here. If you have been making changes on master (you probably shouldn't be,
see [below](#adding-your-own-features)), you might have to fix some merge conflicts when
you do this. When doing so, be careful to respect the upstream changes. 

At this point, you should be in sync with everything on the upstream.

### Adding Your Own Features
When you start working on a new feature, enhancement, or bugfix, it is important
that you start doing so in a **new branch**. This adheres to the standard Git workflow
and makes it easy to logically separate different components/tasks you're working on
and makes them easy to submit to the mainline codebase (using [pull requests](#submitting-a-pull-request)) when you finish and have them
in an acceptable state. For example, if I'm implementing a new device driver for a newfangled Footrix NIC, I would do as follows from
a fresh fork:

    # We want our changes to be based on master
    git checkout master

    # Come up with a meaningful name for our new branch, related to the work we're doing
    git branch footrix-nic

    # Switch to the new branch
    git checkout footrix-nic

Now have fun building!


### Getting Ready for a Pull Request

To submit work to the main codebase, we use a **pull request**. The name is somewhat misleading, as it's not
at all related to a `git pull`. This is essentially a request to have your code merged in. Before you do so,
however, it's a good idea to do some cleanup that will make it easier for the maintainers to 
merge in your code. The most important thing is to integrate any changes that have been made into the upstream
since you started your work. This will avoid annoying conflicts and make the merging process essentially
the same as a fast-forward. To do this, we **rebase** on top of the mainline branch:

    # Fetch from the upstream mainline branch, and merge with *your* repo's master
    git fetch upstream
    git checkout master
    git merge upstream/master

    # If we got new commits from the upstream, we'll now rebase on top of them
    # by taking our commits whole sale and placing them back on top of our master branch.
    # (again, assuming the same branches as above)
    git checkout footrix-nic
    git rebase -i master


If you've made a lot of very small commits, it might make sense to collapse them into
one larger commit with everything logically related. In Git, we call this "squashing." 
We can do this _during_ the rebase using the interactive (`-i`) mode:

    # Rebase all commits made on our footrix-nic branch
    git checkout
    git rebase -i master

This will open up in your default text editor from which you can pick commits to
squash together. 

### Submitting the Pull Request

Now that you've finished your work, you can submit a pull request. First, you should make
sure to commit all your changes (as above) and then push them to *your* Github fork.

    # push to my dev branch
    git push origin footrix-nic


Now, go to the page for your Github fork, and select the appropriate branch. You
can then click the "pull request" button. If you need to make changes after
submitting the pull request, don't worry; the pull request will track new changes
as you push them to the branch for which you created the request.

